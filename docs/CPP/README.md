---
title: C++
date: 2022-05-09
tags:
 - C++
categories:
 - C++
---

# C++学习

## 面向对象

### 对象

面向对象程序设计中的对象，是系统中用来描述客观事物的一个实体，它是用来构成系统的一个基本单位，对象由一组属性和一组行为构成。

### 类

分类所依据的原则是抽象，面向对象程序设计方法中的类，是具有相同属性和服务的一组对象集合。

### 封装

封装是面向对象程序设计方法中的一个重要准则，就是把对象的属性和服务结合成一个独立的系统单位，并尽可能隐蔽对象的内部细节。

### 继承

特殊类的对象拥有其一般类的全部属性和服务，称作特殊类对一般类的继承。

### 多态性

多态性是指在一般类中定义的功能或行为，被特殊类继承之后，可以具有不同的具体实现。



## **面向对象的软件工程**

面向对象的软件工程是面向对象方法在软件工程领域的全面应用。它包括：

1. 面向对象的分析（OOA）
2. 面向对象的设计（OOD）
3. 面向对象的编程（OOP）
4. 面向对象的测试（OOT）
5. 面向对象的软件维护（OOSM）





## 信息的表示与存储



一般来说，如果数制只采用R个基本符号，则成为基R数制，R成为数制的“基数”，而数制中每一固定位置对应的单位值称为“权”。

### 几种进位记数制的转换

#### R进制转换为十进制

将各位数字与它的权相乘，其积相加，和就是十进制数。

$$(111.11) = 1*2^0 + 1*2^1 + 1*2^2 + 1*2^(-1) + 1.2^-2  =  $$ 7.75

#### 十进制转换为R进制

十进制转换为R进制可以将整数部分和小数部分分别转换再拼接起来

##### 整数部分

除R取余法：除以R最后将余数倒叙排列。对于十进制转二进制，就是除二取余法。

68/2 = 34 余0

34/2 = 17 余0

17/2 = 8 余1

8/2 = 4 余0

4/2 = 2 余0

2/2 = 1 余0

1/2 = 0 余1

余数连起来 1000100

$(68)_{10} => (01000100)$



##### 小数部分

可以将小数部分连续乘以R，得到的整数组成R进制数，在将依次乘得的整数拼接。<span style="color:red;">十进制小数通常不能准确地换算为等值的二进制小数（或其他R进制数），有换算误差的存在。</span>

0.3125*2 = <span style="color:red;">0</span>.625

0.625*2 = <span style="color:red;">1</span>.25

0.25*2 = <span style="color:red;">0</span>.5

0.5*2 = <span style="color:red;">1</span>.0

$(0.3125)_{10} => (0.0101)_{2}$





##### 拼接

$(68.3125)_{10} => (01000100.0101)_{2}$



##### 二、八、十六进制相互转换



##### 二转八或十六进制

可以将二进制数的每三位（八进制），每四位（十六进制）看成转换成对应的十进制再用八进制或是十六进制表示然后拼起来。除了左边最高位可以不补0，其他的部分若0不足则需要补0，且中间的0不能省略。

$(1000100)_{2} => 001 + 000 +  100 => 1 + 0 + 4 = (104)_{8}$

$(1000100)_{2} => 01000111(补0)=> 0100 + 0100 => 4+4 = (44)_{16}$

$(1011010.10)_{2} =>001 + 011 + 010 . + 100=> 1 + 3 + 2 + . 4 = (132.4)_{8} $

$(1011010.10)_{2} => 01011010.10(补0) => 0101+1010. + 1000 => 5 + 10  + . 8 = (5A.8)_{16} $



##### 八或十六进制转二进制

将八或十六进制每一位转换成对应的三位（八进制）、四位（十六进制）的二进制数，再拼接起来。

$(F)_{16} => (16)_{10} => (1111)_{2}$

$(7)_{16} => (0111)_{2}$

$(F7)_{16} => (1111 0111)_{2}$

### 信息存储单位

计算机内部，各种信息存储是以二进制编码的形式存在的，信息存储单位通常采用“位”，“字节”，“字”。

- 位（bit）：量度数据的最小单位，表示1位二进制信息。
- 字节（Byte）：一字节由八位二进制数字组成（1Byte = 8bit）。
  - KB = 1024B
  - MB = 1024KB
  - GB = 1024MB
- 字（Word）：字是位的组合，并作为一个独立的信息单位处理。字又称为计算机字，它的含义取决于计算机的类型、字长及使用者的要求。常用的固定字长8位，16位，32位，64位。
- 机器字长：一般指参与运算的寄存器所含有的二进制的位数，它代表了机器的精度，如32位，64位等。

#### 二进制数的编码表示

数值信息在计算机内是采用二进制编码表示的。二进制中使用0表示正号，1表示负号，符号位放在最高位，和数字本身一起作为一个数。

##### 原码

将符号位数字化为0或1，数的绝对值与符号一起编码，即所谓“符号-绝对值表示”的编码，成为原码。

$X = +0101011  [X]_{原} = 00101011$

$X=  -0101011   [X]_{原} = 10101011$

$其中[X]_{原}就是机器数，X就是机器数的真值$



带有符号的纯小数，原码表示就是把小数点左边以为用作符号位。



$X = 0.1011  [X]_{原} = 0.1011$

$X = -0.1011  [X]_{原} = 1.1011$



原码的缺点是不能明确的表示0

$[+0]_{原} = 000000...0 $

$[-0]_{原} = 1000000...0$

并且直接用原码计算的话还需要单独处理符号位。



##### 反码

反码很少使用，一般作为一种编码方式和求补码的中间码。

**正数的反码和原码表示相同**

**负数的反码符号位与原码相同（仍为1），其余各位取反（0变为1,1变为0）**

$X = -110 1011 ---- [X]_{原} = 1110 1011 ---- [X]_{补}= 1001 0100  $

$X = +110 1011 ---- [X]_{原} = 0110 1011 ---- [X]_{补}= 0110 1011  $



**纯小数的反码**

$X = - 0.1011---- [X]_{原} = 1.1011 ---- [X]_{补}= 1.0100  $

$X = + 0.1011---- [X]_{原} = 0.1011 ---- [X]_{补}= 0.0100  $



##### 补码

**负数的补码由该数的反码的最末尾加一求得**

$X=-1010101----- [x]_{原}= 1101 0101 ----[x]_{反} = 1010 1010 ----[x]_{补} = 1010 1011 $

$X=-0.1011----- [x]_{原}= 1.1011 ----[x]_{反} = 1.0100 ----[x]_{补} = 1.0101 $

**正数的原码，补码，反码形式均相同**



**补码的存在使得0的表示是唯一的**

$X=-0 ---- [X]_{原} = 1000 0000 ---- [X]_{反} = 1111 1111 ----[X]_{补} = 0000 0000 （高位舍弃）$

$X= +0 ---- [X]_{原} = 0000 0000 ---- [X]_{反} = 0000 0000 ----[X]_{补} = 0000 0000 $



##### 补码运算规则

- 补码运算的结果仍为补码

- 补码运算进1后最高位舍弃

- 若补码运算结果为负数，要求原码，则应该对补码再求补。

  

  ###### 例题

  $求10-67?$

  $[10]_{补} = 0000 1010$

  $[-67]_{补} =  1011 1101$

  $[10]_{补} + [-67]_{补} =  1100 0111 = [结果]_{补}$

  $[[结果]_{补}]_{补}=> [[结果]_{补}]_{反} +1 => 1011 1001 = -57$

  

  <span style='font-weight:900;color:red;'>若补码计算超过了一定大小，则不保证正确因为有可能会溢出。</span>

  比如64 + 64 = 1000 0000 结果是负数，显然是不正确的，这是因为溢出了。

  