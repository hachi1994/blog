---
title: 大话数据结构和算法
date: 2021-09-30
tags:
 - 算法
 - 数据结构
categories:
 - 算法
 - 数据结构
---

### 算法

#### 算法的定义<img width=50 src='https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdingyue.ws.126.net%2F2019%2F04%2F26%2Fb28f072f389145abb3f1c471e18e7e20.jpeg&refer=http%3A%2F%2Fdingyue.ws.126.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1635578545&t=1e069fc93c7d7dfdb9eb01acf2ba16bf' alt='算法的定义'>

1. 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。
2. 算法特性
   1. 输入输出：算法具有零个或多个输入，具有至少一个或多个输出
   2. 有穷性：指算法在执行有限的步骤之后，自动结束而不会无限循环。
   3. 确定性：算法的每一步骤都具有确定的含义。
   4. 可行性：算法的每一步都必须是可行的，也就是说每一步都能够通过执行有限次数完成。
#### 算法设计要求
1. 正确性：指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。
2. 可读性：算法设计的另一目的是为了便于阅读、理解和交流。
3. 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。
4. 时间效率（算法执行时间）高和存储量（算法在执行过程中需要的最大存储空间）低。
#### 算法效率的度量方法
1. 事前分析估算方法：一个用高级程序语言编写的程序在计算机上运行时消耗的时间取决于下列因素：
   1. 算法采用的策略、方法。
   2. 编译产生的代码质量。
   3. 问题的输入规模。
   4. 机器执行指令的速度。
2. 第一条是算法好坏的根本，第二条由软件来支持，第四条要看硬件性能，抛开计算机硬件软件有关因素，一个程序运行时间，依赖于算法的好坏和问题输入规模，问题输入规模是指输入量的多少。
3. 某个算法，随着n的增大，它会越来越优于另一算法，或者越来越差于另一个算法，这就是事前估算方法的理论依据，通过算法时间复杂度来估算算法时间效率。

#### 算法时间复杂度
1. 定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作T(n)=O(f(n))。它表示随着问题规模n的增大，算法执行时间增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。
2. 这样用大写O()来体现算法复杂度的记法，成为大O记法，三个算法时间复杂度分别为O(n)，O(1)，O(n²)
3. 推导大O阶的方法
   1. 用常数1取代运行时间中的所有加法常数。
   2. 在修改后的运行次数函数中，只保留最高阶项。
   3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。
   4. 得到的结果就是大O阶。
4. 举例
   1. 常数阶
      ```
      let sum = 0, n = 100 //执行1次
      sum = (1+n) * n/2    //执行1次
      console.log(sum)     //执行1次
      ```
      这个算法的运行次数函数是f(n) = 3，根据推导大O阶的方法，把常数项改成1，在保留最高项发现没有最高项，所以该算法时间复杂度为O(1)。
      另外如果这个算法中存在10次sum = (1+n) * n/2语句，无论n为多少结果还是执行12次，所以还是成为具有O(1)的复杂度，又叫常数阶。
    2. 线性阶
      ```
      let sum = 0 
      for(let i = 0;i<n;i++){
          sum += i //时间复杂度为O(1)的程序步骤序列
      }
      ```
      要确定某个算法的阶次，需要分许循环结构的运行情况，所以上面的代码时间复杂程度为O(n)
    3. 对数阶
      ```
      let sum = 1
      while(sum<n){
          sum =  sum *2
      }
      ```
      上面代码每次sum*2都离n更近，所以当多少个2相乘后大于n，则退出循环，所以2^x = n,得到x = log2^n，所以这个循环时间复杂度为O(log2^n)
    4. 平方阶
      ```
      O(n²)
      for(let i = 0;i<n;i++){
          for(let j = 0;j<n;j++){
              //时间复杂度为O(1)的步骤序列   
          }
      }
   
      O(n*m)
      for(let i = 0;i<m;i++){
          for(let j = 0;j<n;j++){
              //时间复杂度为O(1)的步骤序列   
          }
      }
      
      执行次数 n + (n-1) + (n-2) + .... + 1 = n(n+1)/2 = n²/2 + n/2 推导大O为O(n²)
      for(let i = 0;i<n;i++){
          for(let j = i;j<n;j++){
              //时间复杂度为O(1)的步骤序列   
          }
      }
      ```
      上述代码，内层循环为一个时间复杂度为O(n)的步骤序列，而外部循环为O(n)的步骤序列再循环n次，所以上述代码的时间复杂度为O(n²) ，若外层循环n次变成了m次，则时间复杂度为O(n*m)
#### 常用时间复杂度
<img src='https://zardluansource.obs.cn-east-2.myhuaweicloud.com/%E6%97%A0%E6%A0%87%E9%A2%98.png'>
时间复杂度排序
<img src='https://zardluansource.obs.cn-east-2.myhuaweicloud.com/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%8E%92%E5%BA%8F.png'>


### 线性表

#### 顺序存储结构的线性表

顺序存储结构的线性表可以用一个一维数组来表示。
```
//使用js实现一个顺序存储结构的线性表
let list = [4, 5, 2, 6]
//插入一个元素
function insertItem(item, i, list) {
    if (i < 0 || i > list.length) {
        console.log('错误的插入位置！')
    }
    for (let j = list.length - 1; j >= i; j--) {
        list[j + 1] = list[j]
    }
    list[i] = item
    return list
}
//从线性表中删除一个元素并返回删除的元素和删除后的线性表
function delItem(i, list) {
    let delItem = list[i]
    if(list.length==0){console.log('表为空！')}
    if (i < 0 || i > list.length) { console.log('错误的位置！') }
    for(let j = i;j<=list.length-1;j++){
        list[j] = list[j+1]
    }
    list.length--
    return {
        list,
        delItem
    }

}
```
<p style='color:red;'>优点：无须为表示表中元素之间的逻辑关系而增加额外的存储空间；可以快速的存取表中任一位置的元素。</p>
<p style='color:green;'>缺点：插入和删除操作需要移动大量元素；当线性表长度变化较大时，难以确定存储空间的容量；造成存储空间的‘碎片’</p>